def coding(n):
    n = faktorial('1' + oct(bin(n)))
    return n

def decoding(n):
    n = unbin(unokt((str(unfakt(n)))))
    return n

def bin(n):
    m = ""                                             #строка, в которую записываются остатки от деления, образующие конечное двоичное число
    n = int(n)
    while n > 0:                                       #цикл деления десятичного числа на 2
        m = str(n % 2) + m                             #записывается остаток от деления
        n = n//2                                       #для следующего деления берется целая часть, оставшаяся от предыдущего деления
    return int(m)

def oct(n):
    n = str(n)
    if len(n) == 0:
        return ''
    m = oct(n[:-3]) + str(int(n[-3:], 2))           #перевод двоичных триад в десятичные числа, образующие строку, являющуюся восьмеричным числом
    return(m)

def faktorial(n):
    n = int(str(n), 8)
    m = ""                                              #строка, в которую записываются остатки от деления, образующие конечное число
    r = 2                                               #начальное значение делителя
    while n > 0:                                        #цикл деления десятичного числа
        y = str(n % r)                                  #переменная, содержащая остаток от деления исходного числа на делитель
        m = y + m                                       #к строке приписывается остаток
        n = int(n / r)                                  #берется целая часть, оставшаяся от деления
        r = r + 1                                       #делитель увеличивается на единицу
    return m

def unfakt(n):
    k = k1 = len(n)                                 #определяем количество цифр в числе
    nh1 = 0                                         #вводим вспомагательную переменную
    for i in range(k, 0, -1):                       #начинаем проходить по каждой цифре в числе
        factorial = 1
        for j in range(2, k + 1):                   #вычисляем интеграл, соответствующий позиции цифры в числе (начинаем справа, то есть с самого значимого разряда)
            factorial *= j
        nh1 += factorial * int(n[k1 - i])           #умножаем цифру на соответсвующий по позиции факториал и прибавляем к будущему десятичному числу (то есть получаем десятичное число)
        k -= 1
    n = int(nh1)                                    #присвоили изначальному число его же значение в десятичной сс
    nh2 = ""                                        #вводим вторую вспомогательную переменную, куда будем записывать будущее число в 8сс
    while n > 0:                                    #переводим число в 8сс
        nh2 = str(n % 8) + nh2
        n = n // 8
    n1 = nh2
    return n1

def unokt(n1):
    n1 = n1[1:]
    k = len(n1)                                    #определяем количество цифр в числе
    nh3 = ''                                       #вводим вторую вспомогательную переменную, куда будем записывать будущее число
    alphabet = {'0': '000', '1': '001', '2': '010',
                '3': '011', '4': '100', '5': '101',
                '6': '110', '7': '111'}               #вводим словарь
    for i in range(0, k):
        nh3 += alphabet[n1[i]]                     #каждую цифру в числе заменяем на соответствующее ей значение в 2сс
    n2 = nh3
    return n2

def unbin(n2):
    nh3 = n2
    k = len(nh3)
    nh5 = 0
    for i in range(0, k):
        nh5 = nh5 + int(nh3[i]) * (2 ** (k - i - 1))#переводим число в 10сс через степени двойки и позицию цифры в числе
                                                    # #делаем побитовый сдвиг влево
    return nh5

